Reactive C
An experiment/tutorial on implementing reactive programming (RP) ideas in C.
Christophe VG <contact@christophe.vg>

---

The origin of this repository is a paper "Deprecating the Observer
Pattern with Scale.React". The goal of this repository is to implement the
ideas from this paper in C, thus making it available to e.g. embedded
development in C.

Every commit in this repository addresses one of the topics raised in the above
mentioned paper. This way it's an experiment, to see if we can actually
formulate a valid way to write reactive-style code in C, and once completed it
can serve as a tutorial on how to do it.

Rationale

The core of RP is an implementation of the observer pattern. This is also the
starting point of the paper. As a first step we implement this design pattern,
try to identify the same problem areas, as described in the paper, and
formulate solutions to them in subsequent commits.

Scenario

The paper starts from a typical example in UI programming: defining a path,
based on the mouse movement while pressing a button.

We transform this example to one that is applicable to embedded systems, to
wireless sensors in specific. In the context of intrusion detection, one can
implement a small monitor that checks if a parent node in a meshed network,
actually forwards messages to his upstream parent. If this is not the case, the
node might be compromised and the payload causes selective forwarding.

The observing algorithm starts when it detects a network message being sent to
its upstream parent. As of that moment, it will continue to follow all messages
sent by that node and check if the previous message was actually forwarded.
This stops once such a message is observed, but also when a timeout is reached.
At this point, the algorithm will flag this suspicious behavior.

This example maps to the original example: the message being sent to the parent
node maps to the "down" event of the mouse button. Following all messages sent
to the node maps to the "move" event of the mouse button. Finally, the timeout
maps to the "up" event of the mouse button.

Agreed, the example is a little more complex - due to the additional
requirements on the "down" and "move" events, but that just makes the example
more "real" :-)

Implementation 0

The base implementation uses three observers: one for messages sent to the
parent node, a second one for the messages sent by the parent node and a third
one to observe the passing of time to verify possible timeouts. The three
observers use a central data structure, a list of expected messages to be
forwarded, along with the time at which they timeout.

The original paper identifies the following problems with this style of
implementation:

* side effects
  "... observer-based event handling, where clients establish data flow in
   different places through side-effects ..."

* encapsulation
  "Multiple observers are often needed to simulate a state machine ... state is
   stored in variables ... often placed in a broader scope were it can be
   misused by unrelated code ..."

* composability
  "... we cannot, e.g., easily add or remove [observing behavior] ..."

* resource management
  "we need to explicitly install and uninstall the (...) observer and we need
   to remember the subject (point of installation). ... "

* separation of concerns
  "It is often preferable to separate the concerns of constructing [state] and
   displaying it, e.g., as in the model-view-controller (MVC) [31] pattern."

* data consistency
  "We can achieve a separation of concerns with a [state] that itself publishes
   events when it changes. Unfortunately, there is no guarantee for data
   consistency ..."

* uniformity
 "Different methods to install different observers decrease code uniformity."

* abstraction
  "... we cannot abstract over event sources individually."

* semantic distance
  "... the control flow is inverted ..."

Implementation 1

Let's start with some simple alterations that improve the uniformity. Currently
every observable has its own set of methods to add or remove an observer. There
is also an observer type for each observable. As a first step we want to create
a uniform API for dealing with observables and observers.

Observers consist of one function. We can unify their type using a function pointer:

  typedef void (*observer_t)(void *info);

It requires some type casting from the void* to the actual type, but that's the
way it is. See tag "uniform-observer-type" for all changes.

Observables are essentially a list of observers. So we can define a struct to
hold them and accessor functions to manipulate them. We use a linked list of
observer items, tracking the last entree for faster additions

  typedef struct observer_item {
    observer_t observer;
    struct observer_item *next;
  } *observer_item_t;

  typedef struct observable {
    observer_item_t observers;
    observer_item_t last;
  } *observable_t;

  observable_t observable_new   (void);
  void         observable_add   (observable_t, observer_t);
  void         observable_remove(observable_t, observer_t);
  void         observable_notify(observable_t, void*);

Implementing concrete observables now only requires creating a new instance,
adding it and using it in a generic way:

  network_observable = observable_new();

  observable_add(network_observable, observe_msg_to_parent);
  observable_add(network_observable, observe_msg_from_parent);

  observable_notify(network_observable, (void*)&msg);

Through tag "uniform-observer-api" the handling of observers and observables is
completely split of in a separate module with a uniform API.

Implementation 2

Another worry by the original paper is encapsulation. We define a data
structure to hold the information shared by the three observers. It looks that
this is a problem, but in reality it is not. If we store the three observers
and the data structure in a (C) module of their own, with only the three
observers made part of the (public) interface, the data structure is private to
these three functions. See tag "forward-observer-module" for this change. This
commit also includes several clean-ups to separate more clearly the observable
functionality and the simulation support. Also note that now the forward
observer is merely a functionality that can be turned on and off. The three
observers used to implement it are only available inside the module.

Implementation 3

In the previous implementation we also moved the configuration of the observer
(the parent node and a timeout) to its own module, hiding it from the outside.
By itself, this already makes the module a non-reusable component. Given the
task of the forward observer, this might be okay, but other observer
implementations might benefit from multiple instances with different
configurations. So we will make the observer implementation configurable and
reusable.

The observer is (currently) still a simple function (pointer), called by the
observables. We now want to augment this to a function with configuration data,
or environment data. This sounds a lot like a closure ;-)

Tag "observer-closure" introduces a form of closures and uses them to store
configuration data about the observer. So the simple call to the function
pointer ...

  entree->observer(data);

becomes a call to the function of the observer, providing its stored
environment, along with the event data (after also changing some naming):

  observing->function(observing->env, data);

As this new structure is only used internally within the observer module,
nothing is additionally exposed. Only the "add" and "remove" functions get an
additional void* parameter to provide the environment. To manage the
environment on the client-size, we introduce the forward_observer_t type.

Implementation 4

Let's zoom in on the implementation of the forward observer. The creator
function clearly shows that we in fact instantiate three observer functions in
parallel. This is in fact functionally incorrect. The actual algorithm goes
more like this: "Look for messages that are sent to my parent, then wait for a
message sent by my parent with the same payload or wait for a timeout. Any of
these events terminates the waiting."

There are dependencies, with one observed event triggering the creation of two
other observers that live in parallel, and whose observed events are merged and
presented sequentially as feedback to the first.

We might want to implement the forward observer in this way. This can conserve
resources, because we don't need to track messages from the parent as long as
we don't expect a forward; we don't need to track the clock for timeouts as
long as we don't expect a forward. We want to be able to describe the forward
observer in terms of other observes and compose observers together to create
more complex observers.

At the same time we want to invert the inversion of control. Currently, the
three functions are callbacks, with some external controller pulling the
strings. We want to be able to describe the algorithm from the viewpoint of the
algorithm, not in function of some external controlling entity.

Functionally we want something like:

  when an observed "message to parent"
    wait for an observed "message from parent"
          or a timeout

Which we can translate to the following more technical pseudocode:

  // first create some observables (aka EventSources) 
  observable message_to_parent = 
    observe(network_message,
      function(event) {
        if(event.msg.to == parent) { emit event }
      }
    )

  observable message_from_parent = 
    observe(network_message,
      function(event) {
        if(event.msg.from == parent) { emit event }
      }
    )

  observable forward_observer = observe(message_to_parent,
    function(to_event) {
      loop_until(
        or(
          observe(message_from_parent, function(from_event) { 
            if(to_event.payload == from_event.payload) {
              emit "ok" 
            }
          })
          observe(timeout, function(event) { emit "fail"} )
        )
      )
    }
  )
  
  // top-level application tracks events from the forward observer
  // performing the actual action (separation of concern)
  observe(forward_observer, function(Event) { printf("failure"); })

Dependencies:

  main
    forward_observer
      message_to_parent => message_from_parent | timeout
        network_message      network_message

