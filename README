Reactive C
An experiment/tutorial on implementing reactive programming (RP) ideas in C.
Christophe VG <contact@christophe.vg>

---

The origin of this repository is a paper "Deprecating the Observer
Pattern with Scale.React". The goal of this repository is to implement the
ideas from this paper in C, thus making it available to e.g. embedded
development in C.

Every commit in this repository addresses one of the topics raised in the above
mentioned paper. This way it's an experiment, to see if we can actually
formulate a valid way to write reactive-style code in C, and once completed it
can serve as a tutorial on how to do it.

Rationale

The core of RP is an implementation of the observer pattern. This is also the
starting point of the paper. As a first step we implement this design pattern,
try to identify the same problem areas, as described in the paper, and
formulate solutions to them in subsequent commits.

Scenario

The paper starts from a typical example in UI programming: defining a path,
based on the mouse movement while pressing a button.

We transform this example to one that is applicable to embedded systems, to
wireless sensors in specific. In the context of intrusion detection, one can
implement a small monitor that checks if a parent node in a meshed network,
actually forwards messages to his upstream parent. If this is not the case, the
node might be compromised and the payload causes selective forwarding.

The observing algorithm starts when it detects a network message being sent to
its upstream parent. As of that moment, it will continue to follow all messages
sent by that node and check if the previous message was actually forwarded.
This stops once such a message is observed, but also when a timeout is reached.
At this point, the algorithm will flag this suspicious behavior.

This example maps to the original example: the message being sent to the parent
node maps to the "down" event of the mouse button. Following all messages sent
to the node maps to the "move" event of the mouse button. Finally, the timeout
maps to the "up" event of the mouse button.

Agreed, the example is a little more complex - due to the additional
requirements on the "down" and "move" events, but that just makes the example
more "real" :-)

Implementation 0

The base implementation uses three observers: one for messages sent to the
parent node, a second one for the messages sent by the parent node and a third
one to observe the passing of time to verify possible timeouts. The three
observers use a central data structure, a list of expected messages to be
forwarded, along with the time at which they timeout.

The original paper identifies the following problems with this style of
implementation:

* side effects
  "... observer-based event handling, where clients establish data flow in
   different places through side-effects ..."

* encapsulation
  "Multiple observers are often needed to simulate a state machine ... state is
   stored in variables ... often placed in a broader scope were it can be
   misused by unrelated code ..."

* composability
  "... we cannot, e.g., easily add or remove [observing behavior] ..."

* resource management
  "we need to explicitly install and uninstall the (...) observer and we need
   to remember the subject (point of installation). ... "

* separation of concerns
  "It is often preferable to separate the concerns of constructing [state] and
   displaying it, e.g., as in the model-view-controller (MVC) [31] pattern."

* data consistency
  "We can achieve a separation of concerns with a [state] that itself publishes
   events when it changes. Unfortunately, there is no guarantee for data
   consistency ..."

* uniformity
 "Different methods to install different observers decrease code uniformity."

* abstraction
  "... we cannot abstract over event sources individually."

* semantic distance
  "... the control flow is inverted ..."

Implementation 1

Let's start with some simple alterations that improve the uniformity. Currently
every observable has its own set of methods to add or remove an observer. There
is also an observer type for each observable. As a first step we want to create
a uniform API for dealing with observables and observers.

Observers consist of one function. We can unify their type using a function pointer:

  typedef void (*observer_t)(void *info);

It requires some type casting from the void* to the actual type, but that's the
way it is. See tag "uniform-observer-type" for all changes.

Observables are essentially a list of observers. So we can define a struct to
hold them and accessor functions to manipulate them. We use a linked list of
observer items, tracking the last entree for faster additions

  typedef struct observer_item {
    observer_t observer;
    struct observer_item *next;
  } *observer_item_t;

  typedef struct observable {
    observer_item_t observers;
    observer_item_t last;
  } *observable_t;

  observable_t observable_new   (void);
  void         observable_add   (observable_t, observer_t);
  void         observable_remove(observable_t, observer_t);
  void         observable_notify(observable_t, void*);

Implementing concrete observables now only requires creating a new instance,
adding it and using it in a generic way:

  network_observable = observable_new();

  observable_add(network_observable, observe_msg_to_parent);
  observable_add(network_observable, observe_msg_from_parent);

  observable_notify(network_observable, (void*)&msg);

Through tag "uniform-observer-api" the handling of observers and observables is
completely split of in a separate module with a uniform API.
